Emergency Simulator 
User selects simulation category
client/src/pages/simulator
User selects category dropdown
setSelectedcategory updates react state, 
Fetch available cases w triggering useQuery hook

Const (data: cases) - cases variable accesses fetched data
useQuery - react hook to fetch data from APIs
queryKey - cacheKey for query
Change in selected category triggers a new fetch
Enabled: !! selected category
If selectedCategory = null, query not executed
If it doesnt have a value = enabled
Backend 
		












app.get() - GET endpoint (:category = /api/simulation-cases/sepsis (subclasses of cases)
const(category) = req.params
Object destructuring - extracts properties from the req.params object in Express 
Req.params - object with URL segments defined in a colon
Const cases = 
Calls for a function to fetch cases for that category
Res.json - sends cases back to frontend as a JSON object

Data source - filter function filters through case bank and only keeps matching cases mentioned in gCBC

Returns case definitions matching category
Export function - makes the function getCasesByCategory available to other files
Category string = input parameter, returns array of casedefinition objects in JSON, each type represents each case
Return casebank.filter
Filter function filters caseBank and keeps only cases matching the category inside (===_
Returns filtered array

User starts simulation, sends POST -> simulation asession, passes category and user ID, waits for backend to return session ID and case data, updates frontend w sim info



reactQuery useMutation to start simulation, used to manage the state of optimistic data updates
Const function declares startSimulationMutation
When that mutation triggers, mutationFn runs which takes in a category
Const response sends a POST request to backend w category, user ID (fetch API used)
Response returned and sent to onSucess, which runs after async mutation is complete
setActivesimulation updates app state, stores session data, and passes fields retuend from backend


Post endpoint defined
Async (request, response)
Const extracts category and userID from request body
get Random case selects one case at random, returns caseDefinition JSON w fields
Const sessionID makes unique user ID based on timestamp, builds simulation object

Simulation data block 
Const simulation - stores simulationData with storage layer and awaits the result
Res.json sends sessionID and simulationID to client
caseDef sends full case object back to the front end, anything fails, catch function returns error

Step 4 - Handling user interventions
User selects clinical intervention -> sent to backend via POST/api/simulate-case -> Backend updates w vitals and AI-generated explanation -> Frontend update

```typescript
const handleIntervention = (intervention: string) => {
  setSelectedIntervention(intervention);
  interventionMutation.mutate(intervention);
};

setSelectedIntervention updates UI state
interventionMutation triggers useMutation query call

const interventionMutation = useMutation({
Sets up useMutation and creates async mutation hook, used to handle response update
mutationFn: async (intervention: string) => {
    const response = await apiRequest('POST', '/api/simulate-case', {
      caseType: simulation.caseType,
      intervention,
      userId,
      vitals: simulation.vitals,
      stage: simulation.stage
    });
    return response.json();
SENDS THE INTERVENTION TO THE BACKEND
mutate() called and takes intervention as input
Sends POST request w caseType, intervention, userID, vitals, stage -> api simulate cases
Return response,json - parses HTTP response as JSON

onSuccess: (data) => {
    const updatedSimulation = {
      ...simulation,
      id: data.simulationId,
      stage: data.stage,
      vitals: data.updatedVitals,
      interventions: [...simulation.interventions, selectedIntervention!],
      aiExplanations: [...simulation.aiExplanations, data.clinicalExplanation]
    };
   
    setSimulation(updatedSimulation);
    onSimulationUpdate?.(updatedSimulation);
  }
});
```

Executed when backend responds, copies all simulation data, updates ID, appends intervention list and explanation list
And updates frontend accordingly w setSim

BACKEND LOGIC
app.post('/api/simulate-case', async (req, res) => {
  try {
    const { caseType, intervention, userId, vitals, stage, sessionId } = req.body;
    Const caseDefinition = caseBank.find 
App.post - sets up backendroute to handle intervention updates (route handler for HTTP post requests
Try const - destructures front end input values
caseDefinition obtained from casebank

 const aiResult = await generateClinicalExplanation({
      caseType,
      stage: stage || 1,
      vitals: vitals || { heartRate: 120, temperature: 98.6, respRate: 20 },
      intervention
Calls LLM 
GPT explanation
LLM-modified vitals
nextStagerecommendations - optional guidance

    const updatedVitals = { ...aiResult.updatedVitals };
Mutable vials object created from AI output

const currentStage = caseDefinition.stages.find(s => s.stage === (stage || 1));
    let nextStage = (stage || 1) + 1;
   
    if (currentStage) {
      for (const condition of currentStage.branchingConditions) {
        if (intervention.includes(condition.condition)) {
          nextStage = condition.nextStage;
          Object.assign(updatedVitals, condition.vitalsChange);
          break;
        }
      }
    }


Defaults stage to 1 if stage isnt provided, let function = linear stage progression
Loops through branchingConditions
Condition matched by intervention string - nextStage and vitalsChange
??? if intevention includes condition??
Object.assign - copies all properties from one object to a target

 const simulationData = {
      userId,
      caseType,
      stage: nextStage,
      vitals: updatedVitals,
      interventions: [intervention],
      aiExplanations: [aiResult.explanation],
      status: 'active' as const
Sim object has all updated information, status marked as active

const simulation = await storage.createSimulation(simulationData);
Stores updated state and returns object with an ID
Await pauses storing function until simulation data is stored?

res.json({
      simulationId: simulation.id,
      updatedVitals,
      clinicalExplanation: aiResult.explanation,
      nextStageRecommendations: aiResult.nextStageRecommendations,
      stage: nextStage,
      availableInterventions: nextStageInfo?.availableInterventions || [],
      timeLimit: nextStageInfo?.timeLimit,
      criticalActions: nextStageInfo?.criticalActions || [],
      isCompleted: nextStage > caseDefinition.stages.length
    });
  } catch (error) {
    res.status(500).json({ message: "Failed to process simulation" });
isCompleted checks if user passed final stage
res.Json sends all above values back to front end
Generic error response
Have to declare nextstage info
Const nextStageInfo = caseDefinition.stages.(find s =>=== nextStage);

AI clinical explanation generation
Uses generateClinicalExplanation to send a simulation snapshot -> GPT4o and get structured JSON response






export async function generateClinicalExplanation(simulationData: SimulationData): Promise<{
  explanation: string;
  updatedVitals: VitalsData;
  nextStageRecommendations: string[];
}> {
  try {
    const prompt = `
-defines exported async function 
	Input of simulation data JSON object, returns typed object with explanation, updated vitals
Constructs NLP, asks for JSON response with explanation, updated vitals


const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: "You are a pediatric emergency medicine expert providing training explanations. Always prioritize patient safety and evidence-based medicine."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      response_format: { type: "json_object" },
      temperature: 0.7,
    });


Await function sends prompt to GPT via chat-completion API
 const result = JSON.parse(response.choices[0].message.content || "{}");
   
    return {
      explanation: result.explanation || "Unable to generate explanation",
      updatedVitals: result.updatedVitals || simulationData.vitals,
      nextStageRecommendations: result.nextStageRecommendations || []
    };
  } catch (error) {


    throw new Error("Failed to generate clinical explanation: " + (error as Error).message);
  }
}
```


Parses GPT response body from string -> JSON object, and dfeaults to empty if blank
Returns explanation and updatdeVitals and nextstage recommendations
If fails, current vitals and empty arrai
Error func


VitalMonitor
  vitals={simulation.vitals}
  isActive={simulation.status === 'active'}
/>


// AI explanation display
<div className="space-y-4 text-sm">
  <div className="flex items-start space-x-2">
    <div className="w-6 h-6 bg-purple-600 rounded-full flex items-center justify-center flex-shrink-0 mt-1">
      <span className="text-white text-xs">AI</span>
    </div>
    <p className="text-gray-300">
      {latestExplanation}
    </p>
  </div>
</div>
```
Vitals pulled from simulation state
isActive - boolean flag - monitor pulses if sim running
Speech bubble with clinical explanation and dot labeled AI
latestExplanation displayed







X-ray analysis system
GPT 4-o Vision API to detect signs of child abuse in X-ray images - includes risk assesments, fracture detection, and clinical explanations
User uploads X-ray image

handleFileSelect is defined, takes in uploaded file as input
MIME types for file 
If file uploaded isnt valid then code block runs (toast notif)
If file size greater than 10 megabytes 
Smaller file size error message
Passes both error tests, stored in select 


JS API to read local files w/o server upload
Event handler (.onload) sets up when reading process done
setPreview updates react state with base64, displays preview
File read as a base64 URL

User initiatives analysis


Constanalysis Mutation - react query hook to call for APIs
mutationFn: async function handling mutation logic, uploading a file
formData constant created 
KEY VALUE PAIRS FOR MULTIPART UPLOADS
Two fields added via form data - file and userID
Sent to backend endpoint via APIPOST request
If conditional 
Server response not ok
Error message
Ok
Parses, returns JSON to use in onSucess which receives result data
Toast alert (red destructive variant for urgency, shows risk level)
onAnalysis complete called with result
Calls optional callback
Toast - shows eror message if analysis failed

Backedn processing
Upload validation
Image preprocessing
AI analysis
databas e storage
Response formatting


